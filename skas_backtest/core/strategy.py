"""
Base strategy interface and signal definitions for backtesting framework.

This module defines the abstract Strategy class that all trading strategies must inherit from,
along with the signal and result data structures used for communication between strategies
and the backtesting engine.
"""

from abc import ABC, abstractmethod
from dataclasses import dataclass
from datetime import date, datetime
from typing import List, Optional, Dict, Any, Union
from enum import Enum


class SignalAction(Enum):
    """Enumeration of possible trading actions."""
    BUY = "buy"
    SELL = "sell"
    CLOSE = "close"
    HOLD = "hold"


class OptionType(Enum):
    """Enumeration of option types."""
    CALL = "call"
    PUT = "put"


@dataclass
class TradingSignal:
    """
    Represents a single trading signal generated by a strategy.
    
    Attributes:
        symbol: Stock symbol (e.g., "RELIANCE", "TCS")
        strike: Strike price of the option
        expiry: Expiry date of the option
        option_type: Type of option (call/put)
        action: Trading action to take
        quantity: Number of lots to trade
        reason: Human-readable reason for the signal
        confidence: Confidence score (0-1)
        metadata: Additional strategy-specific data
    """
    symbol: str
    strike: float
    expiry: date
    option_type: OptionType
    action: SignalAction
    quantity: int
    reason: str = ""
    confidence: float = 1.0
    metadata: Dict[str, Any] = None
    
    def __post_init__(self):
        if self.metadata is None:
            self.metadata = {}
        
        # Ensure enums are properly set
        if isinstance(self.action, str):
            self.action = SignalAction(self.action.lower())
        if isinstance(self.option_type, str):
            self.option_type = OptionType(self.option_type.lower())


@dataclass
class StrategyResult:
    """
    Result object returned by strategy signal generation.
    
    Contains the list of trading signals along with any additional
    strategy-specific information or analytics.
    """
    signals: List[TradingSignal]
    metadata: Dict[str, Any] = None
    analytics: Dict[str, Any] = None
    
    def __post_init__(self):
        if self.metadata is None:
            self.metadata = {}
        if self.analytics is None:
            self.analytics = {}


class Strategy(ABC):
    """
    Abstract base class for all trading strategies.
    
    All trading strategies must inherit from this class and implement
    the required abstract methods. This ensures a consistent interface
    for the backtesting engine.
    
    Example:
        >>> class MyStrategy(Strategy):
        ...     def get_symbols(self):
        ...         return ["RELIANCE", "TCS"]
        ...     
        ...     def generate_signals(self, current_date, symbols):
        ...         # Strategy logic here
        ...         signals = [...]
        ...         return StrategyResult(signals=signals)
    """
    
    def __init__(self, name: str = None, **kwargs):
        """
        Initialize the strategy.
        
        Args:
            name: Strategy name for identification
            **kwargs: Strategy-specific parameters
        """
        self.name = name or self.__class__.__name__
        self.parameters = kwargs
        self.is_initialized = False
        
        # These will be set during initialization
        self.data_manager = None
        self.portfolio = None
        self.config = None
        
        # Strategy state tracking
        self.current_date = None
        self.historical_signals = []
        self.performance_metrics = {}
    
    def initialize(self, data_manager, portfolio, config) -> None:
        """
        Initialize the strategy with backtesting components.
        
        This method is called once at the start of backtesting to provide
        the strategy with access to data management, portfolio state, and
        configuration.
        
        Args:
            data_manager: DataManager instance for market data access
            portfolio: Portfolio instance for position tracking  
            config: BacktestConfig instance with settings
        """
        self.data_manager = data_manager
        self.portfolio = portfolio
        self.config = config
        self.is_initialized = True
        
        # Call strategy-specific initialization
        self.on_initialize()
    
    def on_initialize(self) -> None:
        """
        Strategy-specific initialization logic.
        
        Override this method to perform any setup required by your strategy,
        such as loading parameters, setting up indicators, etc.
        """
        pass
    
    @abstractmethod
    def get_symbols(self) -> List[str]:
        """
        Return the list of symbols this strategy trades.
        
        Returns:
            List of stock symbols (e.g., ["RELIANCE", "TCS", "INFY"])
        """
        pass
    
    @abstractmethod
    def generate_signals(self, current_date: date, symbols: List[str]) -> StrategyResult:
        """
        Generate trading signals for the given date and symbols.
        
        This is the core method where strategy logic is implemented.
        It should analyze market conditions and return appropriate
        trading signals.
        
        Args:
            current_date: Current trading date
            symbols: List of symbols to analyze
            
        Returns:
            StrategyResult containing trading signals and metadata
        """
        pass
    
    def end_of_day(self, current_date: date, portfolio) -> None:
        """
        End-of-day processing for the strategy.
        
        Called at the end of each trading day for cleanup, state updates,
        or end-of-day analytics.
        
        Args:
            current_date: Current trading date
            portfolio: Current portfolio state
        """
        self.current_date = current_date
        
        # Call strategy-specific end-of-day logic
        self.on_end_of_day(current_date, portfolio)
    
    def on_end_of_day(self, current_date: date, portfolio) -> None:
        """
        Strategy-specific end-of-day processing.
        
        Override this method to implement any end-of-day logic specific
        to your strategy.
        """
        pass
    
    def get_current_positions(self, symbol: str = None) -> List[Dict]:
        """
        Get current positions for the strategy.
        
        Args:
            symbol: Optional symbol filter
            
        Returns:
            List of current positions
        """
        if not self.portfolio:
            return []
            
        positions = self.portfolio.positions
        if symbol:
            positions = [p for p in positions if p.symbol == symbol]
            
        return positions
    
    def get_market_data(self, symbol: str, current_date: date = None) -> Dict[str, Any]:
        """
        Get market data for a symbol.
        
        Args:
            symbol: Stock symbol
            current_date: Date for data (uses strategy current_date if None)
            
        Returns:
            Dictionary containing market data
        """
        if not self.data_manager:
            raise RuntimeError("Strategy not initialized - no data manager available")
            
        date_to_use = current_date or self.current_date
        return self.data_manager.get_market_data(date_to_use, symbol)
    
    def get_option_chain(
        self,
        symbol: str,
        expiry: date,
        current_date: date = None
    ) -> Dict[str, Any]:
        """
        Get option chain data for a symbol and expiry.
        
        Args:
            symbol: Stock symbol
            expiry: Option expiry date
            current_date: Date for data (uses strategy current_date if None)
            
        Returns:
            Dictionary containing option chain data
        """
        if not self.data_manager:
            raise RuntimeError("Strategy not initialized - no data manager available")
            
        date_to_use = current_date or self.current_date
        return self.data_manager.get_option_chain(symbol, expiry, date_to_use)
    
    def calculate_position_size(
        self,
        symbol: str,
        option_price: float,
        max_risk_per_trade: float = None
    ) -> int:
        """
        Calculate appropriate position size based on risk management rules.
        
        Args:
            symbol: Stock symbol
            option_price: Current option price
            max_risk_per_trade: Maximum risk per trade (defaults to config)
            
        Returns:
            Number of lots to trade
        """
        if not self.portfolio or not self.data_manager:
            return 1
            
        # Get lot size for the symbol
        lot_size = self.data_manager.get_lot_size(symbol, self.current_date)
        
        # Calculate maximum risk
        if max_risk_per_trade is None:
            max_risk_per_trade = self.portfolio.get_total_value() * 0.02  # 2% default
        
        # Calculate position size
        max_lots = int(max_risk_per_trade / (option_price * lot_size))
        
        return max(1, max_lots)
    
    def log_signal(self, signal: TradingSignal) -> None:
        """
        Log a trading signal for later analysis.
        
        Args:
            signal: Trading signal to log
        """
        signal_data = {
            "date": self.current_date,
            "signal": signal,
            "portfolio_value": self.portfolio.get_total_value() if self.portfolio else 0,
        }
        self.historical_signals.append(signal_data)
    
    def get_parameter(self, key: str, default: Any = None) -> Any:
        """
        Get a strategy parameter value.
        
        Args:
            key: Parameter name
            default: Default value if parameter not found
            
        Returns:
            Parameter value
        """
        return self.parameters.get(key, default)
    
    def set_parameter(self, key: str, value: Any) -> None:
        """
        Set a strategy parameter value.
        
        Args:
            key: Parameter name
            value: Parameter value
        """
        self.parameters[key] = value
    
    def __str__(self) -> str:
        """String representation of the strategy."""
        return f"{self.name}({', '.join(f'{k}={v}' for k, v in self.parameters.items())})"
    
    def __repr__(self) -> str:
        """Detailed string representation of the strategy."""
        return (f"{self.__class__.__name__}(name='{self.name}', "
                f"parameters={self.parameters}, initialized={self.is_initialized})")